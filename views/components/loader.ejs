<!-- Loading spinner component -->
<div id="page-loader" class="fixed inset-0 bg-white dark:bg-slate-900 z-50 flex items-center justify-center" style="display: none;">
  <div class="text-center">

    
    <!-- Loading text with typewriter effect -->
    <div class="mb-8">
      <h3 class="text-2xl font-bold text-slate-900 dark:text-white mb-3">
        <span class="inline-block animate-pulse">Ladataan</span>
        <span class="inline-block animate-bounce" style="animation-delay: 0.2s;">.</span>
        <span class="inline-block animate-bounce" style="animation-delay: 0.4s;">.</span>
        <span class="inline-block animate-bounce" style="animation-delay: 0.6s;">.</span>
      </h3>
      <p class="text-lg text-slate-600 dark:text-slate-400" id="loading-text">Haetaan tietoja GitHubista</p>
    </div>
    
    
  </div>
</div>

<script>
// Enhanced Loader functionality
class PageLoader {
  constructor() {
    this.loader = document.getElementById('page-loader');
    this.progressBar = document.getElementById('loading-progress');
    this.progressText = document.getElementById('progress-text');
    this.loadingText = document.getElementById('loading-text');
    this.loadingTip = document.getElementById('loading-tip');
    this.progress = 0;
    this.messages = [
      'Haetaan tietoja GitHubista',
      'Lasketaan tilastoja',
      'Valmistellaan sivua'
    ];
    this.tips = [
      'ðŸ’¡ Vinkki: Voit selata sivuja samalla kun tietoja ladataan',
      'ðŸ” GitHub API:n rajoitukset voivat hidastaa latausta',
      'ðŸ“Š Tilastot lasketaan reaaliajassa',
      'âš¡ Cache nopeuttaa toistuvia haku',
      'ðŸŽ¯ Sivut latautuvat optimaalisessa jÃ¤rjestyksessÃ¤'
    ];
    this.currentMessageIndex = 0;
    this.currentTipIndex = 0;
  }

  show() {
    if (this.loader) {
      this.loader.style.display = 'flex';
      this.startProgress();
      this.startMessageRotation();
      this.startTipRotation();
    }
  }

  hide() {
    if (this.loader) {
      // Complete progress bar
      this.updateProgress(100);
      
      // Hide after a short delay
      setTimeout(() => {
        this.loader.style.display = 'none';
        this.reset();
      }, 800);
    }
  }

  startProgress() {
    this.progress = 0;
    this.updateProgress(0);
    
    // Simulate realistic progress
    const interval = setInterval(() => {
      if (this.progress < 85) {
        // Slower progress at the beginning, faster in the middle
        const increment = this.progress < 30 ? Math.random() * 8 : 
                         this.progress < 60 ? Math.random() * 12 : 
                         Math.random() * 6;
        this.progress += increment;
        this.updateProgress(Math.min(this.progress, 85));
      } else {
        clearInterval(interval);
      }
    }, 300);
  }

  updateProgress(percentage) {
    if (this.progressBar) {
      this.progressBar.style.width = `${percentage}%`;
    }
    if (this.progressText) {
      this.progressText.textContent = `${Math.round(percentage)}%`;
    }
  }

  startMessageRotation() {
    this.currentMessageIndex = 0;
    this.updateMessage();
    
    const interval = setInterval(() => {
      this.currentMessageIndex = (this.currentMessageIndex + 1) % this.messages.length;
      this.updateMessage();
    }, 2500);
    
    this.messageInterval = interval;
  }

  startTipRotation() {
    this.currentTipIndex = 0;
    this.updateTip();
    
    const interval = setInterval(() => {
      this.currentTipIndex = (this.currentTipIndex + 1) % this.tips.length;
      this.updateTip();
    }, 4000);
    
    this.tipInterval = interval;
  }

  updateMessage() {
    if (this.loadingText && this.messages[this.currentMessageIndex]) {
      this.loadingText.textContent = this.messages[this.currentMessageIndex];
    }
  }

  updateTip() {
    if (this.loadingTip && this.tips[this.currentTipIndex]) {
      this.loadingTip.textContent = this.tips[this.currentTipIndex];
    }
  }

  reset() {
    this.progress = 0;
    this.currentMessageIndex = 0;
    this.currentTipIndex = 0;
    if (this.messageInterval) {
      clearInterval(this.messageInterval);
    }
    if (this.tipInterval) {
      clearInterval(this.tipInterval);
    }
  }
}

// Global loader instance
window.pageLoader = new PageLoader();

// Show loader immediately when page starts loading
document.addEventListener('DOMContentLoaded', function() {
  // Show loader for a minimum time for better UX
  setTimeout(() => {
    if (window.pageLoader) {
      window.pageLoader.show();
    }
  }, 100);
  
  // Hide loader after page is fully loaded
  window.addEventListener('load', function() {
    setTimeout(() => {
      if (window.pageLoader) {
        window.pageLoader.hide();
      }
    }, 1500); // Minimum loading time for better UX
  });
});

// Show loader on navigation
document.addEventListener('click', function(e) {
  const link = e.target.closest('a[href]');
  if (link && link.hostname === window.location.hostname) {
    // Only show loader for internal navigation
    setTimeout(() => {
      if (window.pageLoader) {
        window.pageLoader.show();
      }
    }, 100);
  }
});
</script>
